<?xml version="1.0" encoding="UTF-8"?> 
<?xml-stylesheet href="/style/rss/style.xsl" type="text/xsl" media="screen"?>

<rss version="2.0">

	<channel>

		<title>Code_J</title>

		<link>http://jakarta.tistory.com/</link>

		<description>My CODE is more(?) than the art, or less(?) that the art..</description>

		<language>ko</language>

		<pubDate>Thu, 11 Nov 2010 13:04:27 +0900</pubDate>

		<generator>Tistory 1.1 (http://www.tistory.com/)</generator>

		<image>

		<title>Code_J</title>

		<url><![CDATA[http://cfile1.uf.tistory.com/image/155808054B41E6C133560B]]></url>

		<link>http://jakarta.tistory.com/</link>

		<description>My CODE is more(?) than the art, or less(?) that the art..</description>

		</image>

		<item>

			<title>캐나다 밴쿠버 계절 날씨 기온</title>

			<link>http://jakarta.tistory.com/78</link>

			<description>오늘 밴쿠버에서 태어난 학원 선생님이 명언을 남기셨다.
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div&gt;
밴쿠버에는 2가지 계절이 있고,&lt;/div&gt;
&lt;div&gt;
2가지 계절이란,&lt;/div&gt;
&lt;div&gt;
There are August and Not August~ !!&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div&gt;
밴쿠버에서 봄여름가을 까지 생활해본 사람으써 저말에 적극 동의한다..&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div&gt;
캐나다는 7~8월을 제외하면 &#039;우기&#039;에 가까울 정도로 비가 오거나 흐린날이 많다..&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div&gt;
물론 한국의 여름처럼 게릴라성 폭우 같은 비가 아닌,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
부슬부슬, 안개비 같은것들을 자주 만날 수 있다..&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
맞아도 그만인 비만 오는 덕에, 비가 와도 거리에서 우산을 쓴 사람의 비율이 절반을 넘지 않는다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
비 많이 온다고 우산 꼭꼭 몇개씩 챙겨오는 사람들을 자주 보는데,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
사실 와보면 알겠지만 아이러니하게 비는 자주오는데 우산이 필요없는 곳 임을 알게된다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
참고로 사진을 올린다.. 전체날씨중 70%는 저런 날씨라 보면된다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile28.uf.tistory.com/original/145B92244CA152B2A07F9C&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile28.uf.tistory.com/image/145B92244CA152B2A07F9C&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_0145.jpg&quot; height=&quot;512&quot; width=&quot;683&quot;/&gt;&lt;/a&gt;&lt;/div&gt;[버나비 지역 주택가]&lt;br /&gt;
&lt;br /&gt;
&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile8.uf.tistory.com/original/165B92244CA152B3A1448A&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile8.uf.tistory.com/image/165B92244CA152B3A1448A&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_0151.jpg&quot; height=&quot;910&quot; width=&quot;683&quot;/&gt;&lt;/a&gt;&lt;/div&gt;[다운타운]&lt;br /&gt;
&lt;br /&gt;
&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile28.uf.tistory.com/original/185B92244CA152B4A2FFE0&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile28.uf.tistory.com/image/185B92244CA152B4A2FFE0&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;IMG_0242.jpg&quot; height=&quot;512&quot; width=&quot;683&quot;/&gt;&lt;/a&gt;&lt;/div&gt;[벤쿠버 남부 주택가]&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
우산 보다는 노*페이스 방한, 방수 자켓은 필수 아이템..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
검정색 방수 자켓하나 있으면 봄여름가을겨울 지내는데 부족한게 없다.. 아주 유용하다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
이억만리 먼나라 답게 한국과는 또 다른 차이가,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
6월경에는 새벽 4:30분이 되면 여명이 밝아오고 저녁 9시나 되어야 어두워 진다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
이것이 의미하는게 무엇일까..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
해가 떠있는 낮의 길이가 무척 길기 때문에 생활패턴에도 조금 차이가 있다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
아침을 조금 늦게 먹는다거나 아침겸 점심으로 브런치 문화가 발달해 있고,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
저녁도 7시 이후에나, 조금 늦게 먹는거 같다..&lt;br /&gt;
긴 오후시간을 이용해 여가시간을 즐기는 사람도 많다..&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
회사-집-회사-집 패턴이 아니라 회사-여가-집의 패턴이 가능한 것..&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
물론 10월 정도되면 해도 7시에나 뜨고 저녁 7시만 지나도 어두워진다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
한국과 대충 비슷해지는 시기가 아닌가 싶다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
여름기온은 최대 30도 정도이고,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
날씨가 건조하기 때문에 햇살은 따갑지만, 전혀 땀이 나지 않는다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
동양인은 이런 강한 햇살에 취약한 피부를 가졌기에,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
남미나 유럽쪽 사람들에 비해 훨씬 피부가 잘 타기 때문에, 선크림, 모자는 필수이며,&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
선글라스나 자외선 차단 코딩된 안경이 필수다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
없으면 눈이 굉장히 피곤하다..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
봄과 가을은 10~20도 수준으로 집안에서는 반팔과 반바지만 입고도 생활이 가능한 수준이나,&lt;br /&gt;
10도 이하로 떨어지는 새벽에는 많이 춥기때문에 편하게 입을 옷은 반팔, 긴팔 일단 다 챙기는 것이 좋다..&lt;br /&gt;
&lt;br /&gt;
겨울은 생활하지 않아서 잘 모르겠으나,&lt;br /&gt;
벤쿠버는 역시 눈보다는 비가 많이 온다 그런다..&lt;br /&gt;
한국보다 겨울은 따듯하고 여름은 시원한 이상적인 날씨다..&lt;br /&gt;
&lt;br /&gt;
그리고 신기한게, 밴쿠버에는 여름에도 모기가 없다.. (한번도 물려 본적이 없음)&lt;br /&gt;
모기 물린데 바르는 약따위 필요없으니 참고하시라..&lt;br /&gt;
&lt;br /&gt;
벤쿠버 날씨는 이것만 알고 가면 일단 OK..&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;blogger-news-widget&quot; style=&quot;width: 100%; text-align: center&quot;&gt;	        

		  					&lt;embed src=&quot;http://api.v.daum.net/static/recombox1.swf&quot; quality=&quot;high&quot; flashvars=&quot;nid=9929726&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;false&quot; bgcolor=&quot;#ffffff&quot; width=&quot;400&quot; height=&quot;80&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;

						&lt;/div&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>Canada 여행</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/78</guid>

			<comments>http://jakarta.tistory.com/78#entry78comment</comments>

			<pubDate>Tue, 28 Sep 2010 11:22:15 +0900</pubDate>

		</item>

		<item>

			<title>HTML 본문 추출(Filtering)에 대한 고찰</title>

			<link>http://jakarta.tistory.com/76</link>

			<description>&amp;nbsp;Crawler에 의해 추출된 웹페이지를 적절히 Indexing 하기 위해서는 해당 문서에 본문영역을 추출(Filtering)하는 것은 검색의 정확도에 있어 매우 중요한 부분이다.&lt;div&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;관련된 연구논문에 따르면 본문과 상관없는 네비게이션, 광고, 페이지 템플릿 등 본문의 내용과 관련없는 부분이 전체 Html 구성 Text에서 40% 이상을 차지한다 그런다. 물론 광고, 네비게이션, 템플릿등은 모든 페이지에서 공통적으로 등장한다면 단순하게 TFIDF과 같은 단순한 확률분포기반 Indexing 만으로도 어느정도 검색과 무관한 데이터로 가려낼 수 있기는 하지만, 이외의 여러가지 다양한 용도로 사용될 수 있고 검색의 방법론 등을 고려해 보았 을때 매우 중요한 기능 임에는 틀림없다.&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;일단 아래의 신문기사의 DOM Tree를 보자.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
(신문기사 주소 :&amp;nbsp;&lt;a href=&quot;http://www.asiae.co.kr/news/view.htm?idxno=2010082215175501055&quot;&gt;http://www.asiae.co.kr/news/view.htm?idxno=2010082215175501055&lt;/a&gt;)&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile28.uf.tistory.com/original/126E0B154C7977E413F9C8&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile28.uf.tistory.com/image/126E0B154C7977E413F9C8&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;HtmlDomTree.png&quot; height=&quot;14215&quot; width=&quot;683&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
다소 길기는 하지만 본문 영역만 자세히 보자.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;본문을 추출하기 위한 가장 간단한 아이디어는 Dom Tree 를 이용하여 Link(a tag)가 설정되어 있지 않는 Text Node를 추출하는 방식이 있으나 이렇게 했을때 불필요한 텍스트를 포함하고 있을 가능성이 매우 크기때문에 2차적인 보정이 필요하다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
아래는 본문영역 추출을 위해 사용될 수 있는 간단한 방법이다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
(몇몇 논문 참조 및 개인연구를 통해 알아낸 가장 적합한 방법이라 생각한다)&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;table width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td bgcolor=&quot;lightgrey&quot;&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
1. Unlink Text Node를 추출하여 Dom의 Node Depth가 같은 Node의 군집을 추출한다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;(실제 구현시에는 인접노드 추출후 재병합하는 방법을 사용하였는데, 이것은 이후에 설명을 하겠다)&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
2. Unlink Text의 밀도를 추출하여 대량의 Text가 밀집된 영역군을 추출하고 1번에서 추출된 후보군집과의 비교를 통해 최종 추출 노드들의 공통 parent node들을 추출하고 parent의 child내의 Text Node의 조합이 본문이 된다. 여기서 추출된 parent node는 1개 이상이 된다. 덧글과 같은 비링크 데이터가 존재할 수 있기 때문이다. 그래서 다수의 후보 node 군이 추출된다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
3. 기사의 내용이 지나치게 짧다거나 기사보다 내용이 긴 덧글 등은 본문 추출의 최대의 적이다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&amp;nbsp;- 사실상 짧은 내용의 기사일 경우 정확한 추출은 불가능하다. (여러 페이지 분석을 통한 템플릿 추출 이후 가능)&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&amp;nbsp;- 덧글 등은 Table 태그의 구조적 Pattern 양상을 보이므로, DOM 의 구조분석을 통해서 덧글 여부를 판별 할 수 있다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
4. 가장 이상적인 방법은 언론사 사이트의 메인페이지에서 동일 level(군집)의 Link를 추출하여, 동일한 페이지 구조 템플릿을 사용하는 페이지들을 분석하여, 본문에 해당되는 DOM Tree의 Path를 추출하는 방법이다.&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;&lt;b&gt;&lt;br /&gt;
&lt;/b&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;한가지 불행한 사실은 본문과 그렇지 않은 부분의 경계가 모호한 페이지도 많다는 것이다. 연구를 하다가 부딛히는 문제들중 본문의 기준을 무엇으로 볼것인가 라는 의문을 던져주는 사이트도 적지 않았다.&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;결국에는 패턴을 통한 기계의 자동화와 인간의 인지에 의한 영역 지정, 기계와 인간의 하이브리드된 방법이 답니다. 다시말해 추출의 대상이 되는 사이트의 XPath 형태의 본문을 포함하는 영역의 DOM 경로 추출 후 추출 값이 정확하지 않을 경우 추가 되거나 제거되어야 할 영역의 규칙을 사람에 의해 수동으로 설정이 가능하도록 하는 방법이 지금으로써는 답이다.&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;물론 불과 몇년전에 불가능으로 보였던 것들에 대한 구현들에 관한 내용이 최근에 계속해서 논문으로 나오고 있는 것을 보면, 수년내에 자동 본문 추출도 완전에 가까운 형태가 되지 않을까 생각된다. 아니면 사람이 좀 고생하는 거고..&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot; style=&quot;text-align: right;&quot;&gt;
&lt;b&gt;김영곤 &amp;lt;gonni21c@gmail.com&amp;gt;&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;blogger-news-widget&quot; style=&quot;width: 100%; text-align: center&quot;&gt;	        

		  					&lt;embed src=&quot;http://api.v.daum.net/static/recombox1.swf&quot; quality=&quot;high&quot; flashvars=&quot;nid=9203678&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;false&quot; bgcolor=&quot;#ffffff&quot; width=&quot;400&quot; height=&quot;80&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;

						&lt;/div&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>Web by Agent</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/76</guid>

			<comments>http://jakarta.tistory.com/76#entry76comment</comments>

			<pubDate>Sun, 29 Aug 2010 06:16:51 +0900</pubDate>

		</item>

		<item>

			<title>Java Html Parser 개발시 유의사항 정리</title>

			<link>http://jakarta.tistory.com/75</link>

			<description>&lt;div&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;&amp;nbsp;Html Parser는 검색엔진 개발에 있어 가장 기본적이면서도 문자열의 논리적 구성을 &amp;nbsp;담당하는 역할을 하는 중요한 모듈이므로, 속도, 안정성, 정확성등 여러가지 섬세하게 고려해야 될 부분이 많다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;&lt;div id=&quot;&quot;&gt;
&amp;nbsp;학생시절 부터 관심이 있어서 Html Parser를 어떻게 만들면 잘 만들수 있을까 참 많은 고민을 한 것 같다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;많은 세월이 흘렀음에도 아직도 해답을 찾지는 못했고,&amp;nbsp;대략적인 실패한 경험들을 토대로 개발시 고려사항들을 정리해 보고자 한다. (참고로 Version 6 정도의 Html Parser가 현재 개발중이다.)&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;1. HTML파서와 XML파서의 제작은 차원이 틀리다.&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;XML 문서와 같은 경우 Well-Formed check를 통해 Tag의 열고닫음, XML의 문법적인 유효성을 강하게 체크하지만,&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
HTML은 그렇지 못하다. 대표적으로 &amp;lt;BR&amp;gt; 과 같은 Tag는 &amp;lt;/BR&amp;gt;과 같이 닫기Tag가 명시적으로 사용되고 있지는 않으므로,&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
HTML Dom Tree 생성시 계층구조 구성을 위한 별도의 처리가 필요하다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;즉, HTML은 모호성(Ambiguous)을 아직까지는 문법적으로 허용하며, 문법의 정확성을 보장할수 없는 변칙적인 언어이다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
대부분의 HTML DOM 파서는 1Pas 시 Well-Formed 조건에 맞게 XML 파서로 파싱이 가능한 형태의 문서를 생성하고,&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
2Pass시 Dom Tree를 생성하는 구조로 되어있다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;
2. 속도와 공간사용량 타협이 필요하다.&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;대부분의 Parser가 아마도 최단 시간내에 Parsing을 완료하는 것을 목표로 할 것이다. 물론 정확하게 파싱해 내는 것은 말 할 것도 없다. 하지만 파서의 속도가 아무리 빠르다 할지라도 Web 상의 정보, 소스를 Network을 통해 가져오는 Html Parser의 특성상 극단적으로 속도를 빠르게 하는 것이 무의미한 작업일 수도 있다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;하지만 속도가 극단적으로 중요한 상황이라면 네트웍에서 데이터를 가져오는 동안 소스의 부분을 여러부분으로 나누어 독립적인 쓰레드의 병렬 파싱을 하도록 한는것도 가능하지만, 가장 간단하면서도 빠른 방법은 일단 데이터를 웹에서 다운받아 StringBuffer나 Char의 배열에 미리 저장해 두고 parsing하는 것이 속도 측면에서는 더 효율적이 이었다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;파싱을 위한 초기작업으로 HTML 문서에서 의미의 단위별로 텍스트의 조합, 즉 Token을 추출하는 Lexing 작업이 선행된다. 파서자체, 객체지향 프로그램 언어적 시각으로 보았을때 파싱의 대상이 되는 Source라는 커다란 객체를 문법으로 정의된 의미의 객체단위로 분리하는 작업이라 할 수 있다. 보통의 경우 Token의 Text와 Token Object가 최소한 1:1의 관계를 이루게 된다. 모든 Parser가 그러하듯 Lexing의 가장 작은 단위동작은 char, 즉 문자 하나를 소스로 부터 가져와 비교하고 그 문자 하나하나가 모여서 하나의 문자열 Token을 이루게 된다. Char단위의 문자열 연산이 상당히 많으며, String 연산 또한 많다. Token의 Size는 예측할 수 없으므로 결국 Token값의 최종결과는 정적으로 할당된 배열에 저장하게 되는데, 토큰 생성시 마다 정적배열의 생성은 극단적으로 H/W power가 약한 시스템에서는 무리가 될 수 있으며, 배열의 전체공간이 Pull인 경우 배열공간을 갱신하는(ex, StringBuffer) 자료구조를 쓸 경우 속도적인 측면에서 손해를 보게 된다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
언제나 그렇듯, 속도와 공간의 타협점을 찾아야 한다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;
3. 사용언어의 추출 : UTF-8, EUC-KR&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;다양한 언어가 공존하고, Charset이 다양하게 존재하는 웹의 구조적 특성상, 웹에서 어떤 데이터를 취득했을때, 그 데이터가 어떠한 Charset을 사용했는지 알아내는 것이 HTML 문서 파싱의 선행 작업이라 할 수 있다. 어떠한 Charset을 사용하는지는 아래와 같은 단서를 이용해서 알 수 있다.
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; id=&quot;&quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;a. Http Protocol Header의 Charset attribute 값에서 추출&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;
b. Html Header 내의 &amp;nbsp;&amp;lt;&lt;/font&gt;&lt;/span&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;font-family: monospace; line-height: normal; font-size: medium; white-space: pre-wrap; &quot;&gt;&lt;span class=&quot;webkit-html-tag&quot; id=&quot;&quot;&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;meta &lt;/font&gt;&lt;/span&gt;&lt;span class=&quot;webkit-html-attribute-name&quot;&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;http-equiv&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;=&quot;&lt;/font&gt;&lt;/span&gt;&lt;span class=&quot;webkit-html-attribute-value&quot;&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;Content-Type&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;&quot; &lt;/font&gt;&lt;/span&gt;&lt;span class=&quot;webkit-html-attribute-name&quot; id=&quot;&quot;&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;content&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;=&quot;&lt;/font&gt;&lt;/span&gt;&lt;span class=&quot;webkit-html-attribute-value&quot;&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;text/html; charset=euc-kr&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;&quot;&amp;gt;&lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt; &lt;/font&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;span style=&quot;font-size: 9pt; &quot;&gt;&lt;font class=&quot;Apple-style-span&quot; id=&quot;&quot;&gt;&lt;font class=&quot;Apple-style-span&quot; color=&quot;#474747&quot;&gt;
c. &amp;lt;Html lang=&quot;ko&quot;&amp;gt; Tag의 lang 속성&lt;/font&gt;&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
a의 경우 서버 자체적으로 제공해 주는 기능이라 최초 Lexing전 charset의 정보를 취득할 수 있으며, b, c의 경우 일단 데이터를 저장하고 pre-reading을 통해 해당정보를 추출해야 한다.(Parsing 속도 측면에서 좋은 방법은 아니며, 초기 ASCII 모드형태로 데이터를 읽으면서 해당정보가 추출된 이후 charset 형태의 맞추어 문자 읽기를 동적으로 변환하는 방법으로 가능하다)&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
저러한 정보를 얻을 수 없는 최악의 상황은 byte연산을 통해 현재 어떠한 type의 문자를 포함하고 있는지 별도의 연산과정이 더&amp;nbsp;필요하다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;&lt;br /&gt;
&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;
4. 무한 루프의 가능성&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;앞서 언급한 바와 같이 html 언어는 모호성을 허용하며, 변칙적인 문법의 사용이나, 정확하지 않은 문법을 사용한 문서들도 상당히 많음을 항상 염두해 두어야 한다. 아마도 모든 파서가 데이터로 부터 커서나 포인터를 증가시켜 문자를 읽어들이면서 파싱이 진행되는 형태를 취하고 있을 것으로 생각된다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;커서의 진행방향이 consume만 하는, 값이 증가만 하는 단방향성만을 가진 다면 큰 문제는 없으나, 경우에 따라서는 커서의 backward가 필요한 경우가 종종 발생한다. 생각해 볼수 있는 가장 심각한 시나리오는 커서가 진행을 못해 파싱 과정에서 파서 자체의 프로세스가 무한루프에 빠지는 경우이다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;커서가 지속적으로 진행하는 단방향성을 가지는 것이 최고의 시나리오이나 그렇지 못한 문법구조를 가졌다면 무한루프의 가능성을 항상 염두해 두어야 되겠다. (불행히도 수많은 Case에 대한 Test 필요)&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;
5. 주석처리상의 문제&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;위에서도 언급한 바와 같이 HTML parser의 문자처가 단방향성을 가진다면 더할 나위 없이 좋겠지만, &amp;lt;script&amp;gt;, &amp;lt;style&amp;gt; &amp;lt;!-- 주석 --&amp;gt;등 과 같은 요소로 인해 사실상 커서의 backward나 미리 읽기버퍼를 현재 문자이후에 등장하는 문자열을 검사해야 하는 경우가 발생한다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;&amp;lt;script&amp;gt;나 &amp;lt;style&amp;gt; 태그의 경우 Value값의 경우 HTML과는 다른 별개의 언어의 문법을 사용하므로 HTML Parsing 모듈이 해당 언어를 파싱할 수 있는 모듈에게 제어권을 넘기거나 혹은 &amp;lt;/script&amp;gt; 나 &amp;lt;/style&amp;gt;이라는 문자열이 나타날때 까지 모든 문자열을 무시해야 한다. 주석의 경우에도 마찬가지 인다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
문자 단위로 커서를 이동하면서 미리읽기를 통해 이후에 뒤따르는 문자열을 분석하는 작업이 필요하다. 속도 측면에서 상당한 마이너스가 아닐까 생각된다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;
6. DOM Object의 경량화&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;b&gt;&lt;br /&gt;
&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;앞서 언급한 바와 같이 Token 과 Token의 Object는 1:1 관계를 이룬다. 일반적으로 Java Application이 실행시 부하량(시간지연)에 가장 많이 영향을 주는 요소는 객체의 생성 시간이다. 객체의 생성량이 크지 않는 경우라면 시스템 성능에 미치는 영향이 미미하겠지만 대형 포털 사이트 메인페이지를 파싱하면 보통 2000개 이상의 Token이 생성된다. Token Object 객체도 똑같이 2000개 이상 생성된다는 소리이며, Tree 생성시 구조에 따라서 생성 객체수는 2배이상 증가 될 수 있다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;일반적인 프로그램에 비해 객체의 생성량이 많고, 페이지의 특성에 따라 생성되는 수를 예측할 수 없기 때문에, 일반적으로 Class 생성시 DOM을 구성하는 단위 객체는 최대한 경량화 되어야한다. C의 구조체처럼 데이터만을 포함될 수 있는 형태가 적절하며 연산이 들어간 method의 사용은 최소화 하는 것이 바람직해 보인다.&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;전체 디자인적으로는 Parsing 을 하는 행위모듈과 파싱후 생성되는 객체, 데이터 모듈을 Class 단위로 철저히 분리해야 한다. 또한 Parsing의 행위모듈의 경우에도 최대한 static 하거나 single object에서 실행되도록 하여, 객체의 생성 자체를 최소화 하는 것이 바람직한 방향으로 보인다.&amp;nbsp;&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&amp;nbsp;객체의 생성이 과도하다면 Object의 메모리 영역을 clone copy를 통해 새로운 객체를 생성하는 Prototype Design Pattern을&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
고려해 볼 수 있으나, Prototype 패턴은 사용 class의 구조적 특성에 따라 효율이 오히려 떨어지는 경우도 있다. 객체 생성시 생성자의 구현이 복잡하다면 고려해 볼 수 있으나, 생성자의 내용이 없는 DOM의 Token 혹은 Node Object 생성시에는 시간적 효율은 거의 없거나 증가하는 양상을 보였다.&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;b&gt;
7. 문법 확장성의 고려&lt;/b&gt;&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&amp;nbsp;새로운 문법에 대한 확장성에 대한 고려도 물론 필요하다. 전체 설계시 영향을 주는 부분이고, 지나친 환장성은 속도, 공간적 효율을 저해한다. 이 부분은 현재 개발중인 &amp;nbsp;YGHtmlParser Release시 별도 언급을 하겠다.&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot;&gt;
&lt;br /&gt;
&lt;/div&gt;
&lt;div id=&quot;aeaoofnhgocdbnbeljkmbjdmhbcokfdb-mousedown&quot; style=&quot;text-align: right;&quot;&gt;
&lt;b&gt;- 김영곤(gonni21c@gmail.com)&amp;nbsp;&lt;/b&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&quot;blogger-news-widget&quot; style=&quot;width: 100%; text-align: center&quot;&gt;	        

		  					&lt;embed src=&quot;http://api.v.daum.net/static/recombox1.swf&quot; quality=&quot;high&quot; flashvars=&quot;nid=9020728&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;false&quot; bgcolor=&quot;#ffffff&quot; width=&quot;400&quot; height=&quot;80&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;

						&lt;/div&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>YG Html Parser</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/75</guid>

			<comments>http://jakarta.tistory.com/75#entry75comment</comments>

			<pubDate>Fri, 20 Aug 2010 13:57:49 +0900</pubDate>

		</item>

		<item>

			<title>YG HttpServer :: 자바 초경량 웹서버 구현 (Java light weight Web Server)</title>

			<link>http://jakarta.tistory.com/74</link>

			<description>&lt;P&gt; Java를 이용한 웹개발시 Servlet 과 같은 Dynamic Page의 구현시에는 Servlet Container를 지원하는 Web Server를 사용하는 수 밖에는 없습니다. Servlet 을 지원하는 Java 다수의 경량 서버가 있습니다만, PDA 같은 임베디드급 머신에 포팅하여 동작 시키기에는 상당한 부담임에는 틀림없습니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt; 그래서 &lt;STRONG&gt;&lt;FONT color=&quot;#5fb636&quot;&gt;임베디드나 PDA 같은 H/W 리소스가 제한적인 장비에서 동작시키기 위한 경량 웹서버&lt;/FONT&gt;&lt;/STRONG&gt;를 취미 생활(?)로 만들어 보았습니다. 이름하여 YG HttpServer 이며 아래 원칙하에 제작되었습니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;- HTTP Fullspec이 아닌 단순 페이지뷰나 파일전송 정도의 기본적 기능만 지원하고 필요한 기능은 사용자가 확장할 수 있을 것&lt;/P&gt;&lt;P&gt;- 장치에 Capability에 맞춰 Setting이 쉬울 것&lt;/P&gt;&lt;P&gt;- Servlet 과 유사한 동적인 페이지를 지원 할 것&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;즉, WebServer의 평가항목 &lt;STRONG&gt;Performance&lt;/STRONG&gt;, &lt;STRONG&gt;Scalability&lt;/STRONG&gt;, Security, Avaliability, Compliance to standards, &lt;STRONG&gt;Flexibility&lt;/STRONG&gt;, Platform requirements, Manageability 중  굵은 글씨로 표시된 항목에만 중점을 두었습니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt; 일단 위와 같은 특성들을 지원하기 위하여 웹서버를 최대한 단순화하여, 필요한 역할을 하는 부분들을 나누고 사용자의 요구에 따라 사용자가 직접 필요한 부분은 tuning 할 수 있도록, &lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;FONT color=&quot;#5fb636&quot;&gt; &lt;STRONG&gt;Server를 구성하는 부분항목에 대해서는 OpenAPI를 제공 기능의 추가, 삭제, 부하량을 고려한 퍼포먼스 튜닝등을 용이하게 하였습니다.&lt;/STRONG&gt;&lt;/FONT&gt;&lt;/P&gt;&lt;P&gt; &lt;/P&gt;&lt;P&gt; 서버의 대략적인 서버 Core 모듈의 구조는 아래와 같습니다.&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile29.uf.tistory.com/original/1111E90B4B3F0EDF0F72B6&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile29.uf.tistory.com/image/1111E90B4B3F0EDF0F72B6&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;ckServerUml.jpg&quot; height=&quot;313&quot; width=&quot;644&quot;/&gt;&lt;/a&gt;&lt;/div&gt;  &lt;/P&gt;&lt;P&gt;1. MicroWebServer에서 ServerSocket의 생성 관리 및 Client Socket Binding을 담당하여,&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;2. ServiceMapper에서는 생성된 Client Socket의 Header를 parsing 하여 요구 Resource를 추출, Resource를 처리할 수 있는 Service Object에 넘겨주는 역할을 합니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;3. AbstractService를 extends 하여 사용자가 원하는 형태의 서비스를 구현도 가능하며, 현재 Web Server에서는 기본적으로 Html이나 일반적은 파일을 전송하는 StaticResourceService와 Servlet과 같은 동적인 웹페이지를 사용자가 구현할 수 있도록 경량화한 GdpService를 지원합니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;4. Gdp 요청에 대해서는 사용자가 직접 작성한 Gdplet Object에 전달되어 개별적인 동적 처리가 이루어 지는 구조입니다.&lt;/P&gt;&lt;P&gt;4-1. 예제로 쓰인 Hello gdp 와 파일전송은 이후에 살펴보겠습니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;5. IServiceScheduler는 다수의 요청의 처리를 위한 스케쥴러 Interface이며, 사용자는 Device의 Capa에 맞추어 적절한 형태의 스케쥴러를 직접 작성할 수도 있습니다.&lt;/P&gt;&lt;P&gt;5-1. 기본적으로 내장된 DefaultServiceScheduler는 ThreadPool의 형태로 구현되었고, Client의 요구를 순차적으로 저장했다가 처리하는 저장 순서에 따라 처리하는 Unbounded queue 가 사용되었으며, Pool 공간은 10입니다.(동시에 10건 이내의 요청만 처리 가능합니다.)&lt;/P&gt;&lt;P&gt; &lt;/P&gt;&lt;P&gt;눈치 채신분도 많겠지만,&lt;/P&gt;&lt;P&gt;위의 웹서버는 Java의 NIO가 아닌 Standard IO로 구동되는 구조입니다. Standard IO는 다수의 동시처리를 위해 쓰레드를 사용할 수 밖에 없습니다. &lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;FONT color=&quot;#5fb636&quot;&gt;Performance가 떨어지는 Standard IO + ThreadPool 기반으로 제작한 이유는 NIO는 OS에 종속성이 있으며, JVM에 제약이 있는 임베디드 장비에서는 정상적인 동작이 어려울 수 도 있고, 애초에 의도가 대량 접속처리가 아니라 최대한 가벼운 환경에서 동작되는것을 목표로 하였기 때문입니다.&lt;/FONT&gt;&lt;/P&gt;&lt;P&gt;&lt;FONT color=&quot;#5fb636&quot;&gt;&lt;STRONG&gt;NIO 버전은 현재 ME 버전이 아닌 SE 버전에서 적용될 예정입니다.&lt;/STRONG&gt;&lt;/FONT&gt;&lt;/P&gt;&lt;P&gt;&lt;FONT color=&quot;#5fb636&quot;&gt;&lt;STRONG&gt;&lt;br /&gt;
&lt;/STRONG&gt;&lt;/FONT&gt;&lt;/P&gt;&lt;P&gt;아래는 위에서 설명한 Server의 Core 모듈입니다. (상업적 이용은 불가입니다. 모든 소스 오픈예정)&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://jakarta.tistory.com/attachment/cfile10.uf@133349284B3F269E8FAB38.jar&quot;&gt;&lt;img src=&quot;http://cfs.tistory.com/blog/image/extension/unknown.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; org.ygsoft.webserver.core_20100102.jar&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;앞서 설명한 바와 같이 기본 Service 만을 탑재하여 아래와 같이 Cosole에서 실행 시킬 수도 있습니다.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile27.uf.tistory.com/original/2026100F4B3F18085185D5&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile27.uf.tistory.com/image/2026100F4B3F18085185D5&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;serverEx.jpg&quot; height=&quot;296&quot; width=&quot;683&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;주석으로 처리된 부분은 GpeService를 추가시키는 부분으로 사용자가 작성한 Gdplet 서비스의 탑재도 가능합니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;Gdp는 Gonni Dynamic Page의 약자로 서블릿과 같이 사용자가 동적인 웹페이지를 구성할 수 있도록 제공하는 API를 제공합니다. &lt;STRONG&gt;&lt;FONT color=&quot;#5fb636&quot;&gt;사용자는 Gdplet 이라는 class의 service(XRequest req, XResponse res) method만 구현하면 됩니다.&lt;/FONT&gt;&lt;/STRONG&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;아래는 Hello GDP 예제입니다.&lt;STRONG&gt;&lt;br /&gt;


&lt;/STRONG&gt;&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile6.uf.tistory.com/original/1713BF244B3F1C1E636903&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile6.uf.tistory.com/image/1713BF244B3F1C1E636903&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;Hello.jpg&quot; height=&quot;443&quot; width=&quot;650&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;Http 프로토콜은 기본적으로 Header와 Body의 구조로, &lt;STRONG&gt; Header&lt;/STRONG&gt;에는 기본적으로 사용자가 Client에게 전송하는 data의 mime type의 지정이 필요하며,  &lt;STRONG&gt;Body&lt;/STRONG&gt;부분에 실제 전송을 위한 data를 write 해주면 됩니다. (API상으로는 Character와 Binary 두가지 형태의 write를 모두 지원합니다. )&lt;/P&gt;&lt;P&gt; &lt;/P&gt;&lt;P&gt;아래는 위의 Gdp 예제의 실행결과 입니다.&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile23.uf.tistory.com/original/1838B3284B3F1D07573A97&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile23.uf.tistory.com/image/1838B3284B3F1D07573A97&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;HelloBrowser.jpg&quot; height=&quot;255&quot; width=&quot;578&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;새로고침 버튼을 눌렀을 경우 페이지가 동적으로 현재시간에 맞추어 갱신되는 것을 확인 할 수 있습니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;아래는 해당 모듈을 이용하여 만들어본 GUI 모듈입니다. 실행시 TrayIcon에 서버 실행이 활성된 Icon이 생성되고 사용자가 웹서버의 Root 폴더 지정 및 현재 서버의 상태를 확인 할 수 있습니다.(귀찮아서 할 수 있는게 많은데 여기까지 밖에 못했네요)&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile5.uf.tistory.com/original/1839CD194B3F1F2B0B31E2&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile5.uf.tistory.com/image/1839CD194B3F1F2B0B31E2&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;trayIcon.jpg&quot; height=&quot;159&quot; width=&quot;132&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;트레이 아이콘, Server 의 상징인 &#039;G&#039; 모양이 아이콘이 생성되었음을 확인 할 수 있습니다. ^^&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile27.uf.tistory.com/original/1939CD194B3F1F2B0C1610&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile27.uf.tistory.com/image/1939CD194B3F1F2B0C1610&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;ygServerSetting.jpg&quot; height=&quot;397&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;서버 설정화면, Http File Server 운용을 위한 root dir 설정 및 서버의 로그, 순간 접속량 등을 확인 할 수 있습니다. &lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;아래의 파일은 UI 및 일부 Gdp를 포함하는 샐행파일이 포함된 Jar 파일입니다. (실행은 콘솔에서 java -jar  cKserver.jar 이며, 반드시 동일 폴더에 org.ygsoft.webserver.core_20100102.jar 파일이 같이 있어야만 동작합니다.)&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://jakarta.tistory.com/attachment/cfile26.uf@1946BB284B3F26B182AD40.jar&quot;&gt;&lt;img src=&quot;http://cfs.tistory.com/blog/image/extension/unknown.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; cKserver.jar&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;Gdplet 테스트를 위해 UI 및 Demo gdp 가 포함된 Eclipse Project도 첨부합니다. 관심있으신 분들은 아주 적절하게 필요한 서비스를 확장하여 사용할 수 있으리라 확신합니다. (Gdplet 개발시 공유해 주시면 감사 ^^)&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://jakarta.tistory.com/attachment/cfile29.uf@1318B3264B3F26EAB5F5AF.zip&quot;&gt;&lt;img src=&quot;http://cfs.tistory.com/blog/image/extension/zip.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; MicroWebServerEx.zip&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;해당 프로젝트 내에서 Client에서 WebServer로 파일을 전송하는 gdp 예제도 포함되어 있습니다.  &lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile9.uf.tistory.com/original/142B6E0E4B3F222E5B1CFE&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile9.uf.tistory.com/image/142B6E0E4B3F222E5B1CFE&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;fileSend.jpg&quot; height=&quot;217&quot; width=&quot;640&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;아래의 웹페이지에 파일 전송시 서버 실행을 하였던 jar 파일이 포함된 폴더내에 download 폴더가 생성 파일이 저장되는 구조입니다. 원격지에서 집 Server에 파일 전송이 가능하죠. 본 예제를 참고, gdp를 확장하여 다양한 형태의 데이터 송수신 서비스를 구현 할 수 있을 거라 생각됩니다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;다음 버전에는 아래의 기능들을 추가해 볼까합니다.&lt;/P&gt;&lt;P&gt;- Session을 추가하여 간단한 사용자 인증 구현 (Open API 제공)&lt;/P&gt;&lt;P&gt;- Reflection을 활용하여 Service를 추가하는 기능&lt;/P&gt;&lt;P&gt;- GUI 개선&lt;/P&gt;&lt;P&gt;- GDP 예제 : 웹기반 파일 탐색기, CCTV, 원격제어 &lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;P style=&quot;text-align: right&quot;&gt;어디까지나 취미생활 인지라 다음이 언제가 될 지는 모르겠네요..ㅋㅋ &lt;/P&gt;&lt;P style=&quot;text-align: right&quot;&gt;&lt;STRONG&gt;&lt;FONT color=&quot;#5fb636&quot;&gt;김영곤 (mailto:gonni21c@gmail.com)&lt;/FONT&gt;&lt;/STRONG&gt;&lt;/P&gt;&lt;P&gt;&lt;br /&gt;


&lt;/P&gt;&lt;div class=&quot;blogger-news-widget&quot; style=&quot;width: 100%; text-align: center&quot;&gt;	        

		  					&lt;embed src=&quot;http://api.v.daum.net/static/recombox1.swf&quot; quality=&quot;high&quot; flashvars=&quot;nid=5307114&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;false&quot; bgcolor=&quot;#ffffff&quot; width=&quot;400&quot; height=&quot;80&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;

						&lt;/div&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>YG Web Server</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/74</guid>

			<comments>http://jakarta.tistory.com/74#entry74comment</comments>

			<pubDate>Sat, 02 Jan 2010 19:55:19 +0900</pubDate>

		</item>

		<item>

			<title>롤백(Rollback) 구현을 위한 디자인 패턴..</title>

			<link>http://jakarta.tistory.com/73</link>

			<description>&lt;P&gt;디자인패턴에서 일반적으로 Rollback 구현을 위해서 memento 패턴을 소개하고 있습니다만,&lt;br /&gt;
일반적으로 Job이나 Work를 생성하는 유형의 Application의 구현에서,&lt;/P&gt;

&lt;P&gt;Rollback을 기능을 구현하는 것이 그다지 쉬운 구현은 아니다. (memento로 커버하기엔 복잡도가 높다)&lt;/P&gt;

&lt;P&gt;더 정확하게 말해 특정기능을 부분부분 프로세스로 나누어 프로세스를 하나하나 순차적으로 수행을 하는 과정을 하나의 Job으로 본다면,&lt;/P&gt;

&lt;P&gt;각 프로세스에 대한 구현을 역으로 수행하는 부분의 구현이 필요하다.&amp;nbsp;&lt;/P&gt;

&lt;P&gt;일반적으로 특정 프로세스가 수행될때 수행의 상태 정보를 저장해두고,&lt;br /&gt;
사용자에 의해 Rollback 요청이 왔을때 &amp;nbsp;지금까지 했던 작업 상태 정보를 역으로 수행하는 프로세스를 역순으로 가동시켜야 한다. (상당히 귀찮은 작업이다)&lt;br /&gt;
&lt;br /&gt;그림으로 나타내면 대략적으로 아래와 같은 구동흐름을 보인다.&lt;/P&gt;

&lt;P&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile27.uf.tistory.com/original/13445D0F4AB0FE2456309A&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile27.uf.tistory.com/image/13445D0F4AB0FE2456309A&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;슬라이드1.jpg&quot; height=&quot;275&quot; width=&quot;668&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;

&lt;P&gt;하나의 Job이 A -&amp;gt; B -&amp;gt; C -&amp;gt; D와 같은 4개의 단계의 프로세스로 실행되는 흐름을 가진다고 가정했을때,&lt;br /&gt;
C가 실행중인 시점에 사용자로 부터 Cancel 요청이 왔을때,&lt;br /&gt;
각 프로세스별 Rollback 프로세스가 C&#039; -&amp;gt; B&#039; -&amp;gt; A&#039; 의 순서로 실행되어야,&lt;br /&gt;
해당 Job의 이전 상태로 복원되는 Rollback이 최종 수행된다&lt;br /&gt;
&lt;br /&gt;하나의 Job Class내에 이러한 Rollback의 구동흐름을 구현은 상당히 복잡해 진다.&lt;br /&gt;
(프로세스, 롤백프로세스를 구현하고 현재 실행상태와 흐름을 관리하는 코드를 구현해야 하기 때문이다)&lt;/P&gt;

&lt;P&gt;이러한 복잡한 구현을 다른 class로 분리하고,&lt;br /&gt;
프로세스의 구현에 어려운 상태정보 관리를 개선하고자 아래와 같은 개념의 디자인의 흐름을 생각하게 되었다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile22.uf.tistory.com/original/15445D0F4AB0FE25576D64&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile22.uf.tistory.com/image/15445D0F4AB0FE25576D64&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;슬라이드2.jpg&quot; height=&quot;515&quot; width=&quot;662&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/P&gt;

&lt;P&gt;프로세스를 하나의 클래스로 정의하여,&lt;br /&gt;
하나의 프로세스 클래스 내에서 해당 프로세스의 수행 상태를 저장하고, 해당 프로세스의 rollback code까지 포함한다.&lt;br /&gt;
&lt;br /&gt;Tree와 같은 형태로 프로세스를 구성하여,&lt;br /&gt;
Root로 부터 특정 프로세스를 연쇄적으로 수행하여(재귀recursive호출),&lt;br /&gt;
특정 시점에 사용자로 부터 cancel 요청이 왔을때,&lt;br /&gt;
Tree를 역으로 순회하면서 rollback 프로세스를 수행하면,&lt;br /&gt;
A -&amp;gt; B -&amp;gt; C -&amp;gt;&amp;nbsp;userCancel -&amp;gt;&amp;nbsp;C&#039; -&amp;gt; B&#039; -&amp;gt;A&#039;의 흐름으로 프로세스가 진행된다.&lt;br /&gt;
&lt;br /&gt;Tree 기반의 수행 흐름을 구현하기 위해, &lt;br /&gt;
Chain of Responsibility 와 Template Method 디자인 패턴의 아이디어를 적절히 조합하여 하나의 프로세스를 추상화한 아래와 같은 클래스를 구현하였다.&lt;br /&gt;
&lt;br /&gt;

&lt;TABLE style=&quot;BORDER-COLLAPSE: collapse&quot; cellSpacing=1 cellPadding=1 width=673 bgColor=#e8e8e8&gt;

&lt;TBODY&gt;

&lt;TR&gt;

&lt;TD style=&quot;BORDER-RIGHT: #2b8400 1px solid; BORDER-TOP: #2b8400 1px solid; BORDER-LEFT: #2b8400 1px solid; BORDER-BOTTOM: #2b8400 1px solid&quot; width=&quot;100%&quot;&gt;

&lt;P&gt;&amp;nbsp;&lt;br /&gt;
import java.util.*;&lt;/P&gt;

&lt;P&gt;public abstract class AbstractJobProcess{&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;private static int pid = 0;&lt;br /&gt;
&amp;nbsp;private String strCommand = null;&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;private AbstractJobProcess nextProcess = null;&lt;br /&gt;
&amp;nbsp;private volatile boolean cancelByUser = false;&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;private ArrayList&amp;lt;IProcessEventListener&amp;gt; lstListeners = null;&lt;br /&gt;
&amp;nbsp;//private Vector&amp;lt;String&amp;gt; lstResultLog = null;&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;protected AbstractJobProcess(String command)&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;pid++;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;strCommand = command;&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public String getCommand()&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;return this.strCommand;&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public AbstractJobProcess addNextProcess(AbstractJobProcess process)&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;this.nextProcess = process;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;return this.nextProcess;&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public void cancel()&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;this.cancelByUser = true;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;if(this.nextProcess != null) this.nextProcess.cancel();&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public boolean start()&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;if(this.cancelByUser) return false;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;if(this.process())&lt;br /&gt;
&amp;nbsp;&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;if(this.cancelByUser){&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// excute rollback process&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.rollback();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(this.nextProcess != null)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean nextJobResult = this.nextProcess.start(); &lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if(nextJobResult) &lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.rollback();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;} else {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;this.rollback();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public abstract boolean process();&amp;nbsp; //&amp;nbsp;정상 process 구현&lt;br /&gt;
&amp;nbsp;public abstract boolean rollback();&amp;nbsp; // rollback 구현&lt;br /&gt;
&lt;br /&gt;}&lt;/P&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;br /&gt;
&amp;nbsp;위의 추상클래스를 상속하여 개별 프로세스를 구현할 수 있으며, 구현 클래스에서는 abstract method인 process와 rollback을 구현해야 한다. (프로세스별 동작 방식과 상태 저장 방식이 틀리기 때문이다.)&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;process와 rollback외 추가적으로 프로세스의 재귀적인 호출을 위한 start() method와 수행중인 Job의 취소를 위한 cancel을 제공하며, cancel()&amp;nbsp;method 또한&amp;nbsp;연결 프로세스간&amp;nbsp;재귀적인&amp;nbsp;호출이 이루어 지는 구조이다&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;프로세스간 chain과 같은 연결구조를 설정하기 위해 addNextProcess(AbstractJobProcess process) method도 제공한다. &lt;br /&gt;
&lt;br /&gt;&amp;nbsp;이 외에 프로세스에 상태정보를 event로 전송하기 위해 Observer Pattern을 추가적으로 적용할 수도 있다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;위의 AbstractJobProcess를 이용하여 아래 구조의 rollback을 수행하는 Job(Task)을 구현해 보자.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile3.uf.tistory.com/original/1418500E4AB4298954305D&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile3.uf.tistory.com/image/1418500E4AB4298954305D&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;uml0.jpg&quot; height=&quot;238&quot; width=&quot;650&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
TempJob은 Porcess A, B, C, D 순서의 실행구조를 가진 임의의 Job Class로 job의 시작과 중단을 위한 start()와 cancelJob() method를 제공한다. &lt;br /&gt;
&lt;br /&gt;ProcessA .. D는 Console에 각 프로세스의 message를 0.3초간 지연후 출력해주는 구현이 되어있다. process의 수행중 cancel 요청이 왔을때 실행시점에 rollback 프로세스가 실행됨을 보여주기 위해 임의의 sleep을 삽입하였다.&lt;br /&gt;
&lt;br /&gt;코드는 아래와 같다. ( Process 별 구현은 동일 )&lt;br /&gt;


&lt;TABLE style=&quot;BORDER-COLLAPSE: collapse&quot; cellSpacing=1 cellPadding=1 width=673 bgColor=#e8e8e8&gt;

&lt;TBODY&gt;

&lt;TR&gt;

&lt;TD style=&quot;BORDER-RIGHT: #2b8400 1px solid; BORDER-TOP: #2b8400 1px solid; BORDER-LEFT: #2b8400 1px solid; BORDER-BOTTOM: #2b8400 1px solid&quot; width=&quot;100%&quot;&gt;

&lt;P&gt;&amp;nbsp;public class ProcessA extends AbstractJobProcess{&lt;/P&gt;

&lt;P&gt;&amp;nbsp;protected ProcessA(String command) {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;super(command);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;}&lt;/P&gt;

&lt;P&gt;&amp;nbsp;@Override&lt;br /&gt;
&amp;nbsp;public boolean process() {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;try { Thread.sleep(300); } catch (InterruptedException e) {}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;System.out.println(&quot;A excuted by &quot; + this.getCommand());&lt;br /&gt;
&amp;nbsp;&amp;nbsp;return true;&lt;br /&gt;
&amp;nbsp;}&lt;/P&gt;

&lt;P&gt;&amp;nbsp;@Override&lt;br /&gt;
&amp;nbsp;public boolean rollback() {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;System.out.println(&quot;A&#039; excuted by &quot; + this.getCommand());&lt;br /&gt;
&amp;nbsp;&amp;nbsp;return true;&lt;br /&gt;
&amp;nbsp;}&lt;/P&gt;

&lt;P&gt;}&lt;/P&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;br /&gt;
A, B, C, D 4개의 Process를 연결하여 실행시키는 코드는 아래와 같다. (TempJob.java)&lt;br /&gt;


&lt;TABLE style=&quot;BORDER-COLLAPSE: collapse&quot; cellSpacing=1 cellPadding=1 width=673 bgColor=#e8e8e8&gt;

&lt;TBODY&gt;

&lt;TR&gt;

&lt;TD style=&quot;BORDER-RIGHT: #2b8400 1px solid; BORDER-TOP: #2b8400 1px solid; BORDER-LEFT: #2b8400 1px solid; BORDER-BOTTOM: #2b8400 1px solid&quot; width=&quot;100%&quot;&gt;

&lt;P&gt;&amp;nbsp;import java.util.Observable;&lt;/P&gt;

&lt;P&gt;public class TempJob extends Observable{&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;private AbstractJobProcess rootProcess = null;&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public TempJob()&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;;&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public void setProcess(AbstractJobProcess buildedProcess)&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;this.rootProcess = buildedProcess;&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public void startJob()&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;this.rootProcess.start();&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public void cancelJob()&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;System.out.println(&quot;[LOG] Request to cancel..&quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;if(this.rootProcess != null)&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;this.rootProcess.cancel();&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
&amp;nbsp;public static void main(String...v)&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;//&amp;nbsp;A, B, C, D 연결된 Process를 생성한다&lt;br /&gt;
&amp;nbsp;&amp;nbsp;AbstractJobProcess rootProc = new ProcessA(&quot;procA&quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;rootProc.addNextProcess(new ProcessB(&quot;procB&quot;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.addNextProcess(new ProcessC(&quot;procC&quot;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.addNextProcess(new ProcessD(&quot;procD&quot;));&lt;br /&gt;
&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;final TempJob job = new TempJob();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;job.setProcess(rootProc);&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;&amp;nbsp;// 생성된 Process를 실행한다.&lt;br /&gt;
&amp;nbsp;&amp;nbsp;job.startJob();&lt;br /&gt;
&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;
}&lt;/P&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;br /&gt;
chain의 형태로 아래와 같이 프로세스를 생성후 연결 시켰다&lt;br /&gt;


&lt;TABLE style=&quot;BORDER-COLLAPSE: collapse&quot; cellSpacing=1 cellPadding=1 width=673 bgColor=#ffffff&gt;

&lt;TBODY&gt;

&lt;TR&gt;

&lt;TD style=&quot;BORDER-RIGHT: #dadada 1px solid; BORDER-TOP: #dadada 1px solid; BORDER-LEFT: #dadada 1px solid; BORDER-BOTTOM: #dadada 1px solid&quot; width=&quot;100%&quot;&gt;AbstractJobProcess rootProc = new ProcessA(&quot;procA&quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;rootProc.addNextProcess(new ProcessB(&quot;procB&quot;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.addNextProcess(new ProcessC(&quot;procC&quot;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.addNextProcess(new ProcessD(&quot;procD&quot;));&lt;br /&gt;
&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;br /&gt;
&lt;br /&gt;해당 프로그램을 실행하면 아래와 같이 기대한 A-&amp;gt;B-&amp;gt;C-&amp;gt;D의 연속적인 실행이 이루어 지는 것을 확인 할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;table style=&quot;display: inline; border-collapse: collapse&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://cfile30.uf.tistory.com/original/1979550D4AB42CF9723461&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile30.uf.tistory.com/image/1979550D4AB42CF9723461&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;result.jpg&quot; height=&quot;100&quot; width=&quot;302&quot;/&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br /&gt;
&lt;br /&gt;Process가 실행중에 사용자에 의한 Cancel 요청시 Process의 rollback이 이루어 지는것을 확인하기 위해서,&lt;br /&gt;
main method 내에 아래의 code를 삽입하였다.&lt;br /&gt;
&lt;br /&gt;

&lt;TABLE style=&quot;BORDER-COLLAPSE: collapse&quot; cellSpacing=1 cellPadding=1 width=673 bgColor=#ffffff&gt;

&lt;TBODY&gt;

&lt;TR&gt;

&lt;TD style=&quot;BORDER-RIGHT: #dadada 1px solid; BORDER-TOP: #dadada 1px solid; BORDER-LEFT: #dadada 1px solid; BORDER-BOTTOM: #dadada 1px solid&quot; width=&quot;100%&quot;&gt;&amp;nbsp;public static void main(String...v)&lt;br /&gt;
&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;// build proc&lt;br /&gt;
&amp;nbsp;&amp;nbsp;AbstractJobProcess rootProc = new ProcessA(&quot;procA&quot;);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;{&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;rootProc.addNextProcess(new ProcessB(&quot;procB&quot;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.addNextProcess(new ProcessC(&quot;procC&quot;))&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.addNextProcess(new ProcessD(&quot;procD&quot;));&lt;br /&gt;
&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;final TempJob job = new TempJob();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;job.setProcess(rootProc);&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&lt;STRONG&gt;&amp;nbsp;// cancel job&lt;br /&gt;
&amp;nbsp;&amp;nbsp;new Thread() {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public void run() {&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try { Thread.sleep(800); } catch (InterruptedException e) {}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;job.cancelJob();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br /&gt;
&amp;nbsp;&amp;nbsp;}.start();&lt;/STRONG&gt;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;job.startJob();&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&lt;br /&gt;
&amp;nbsp;}&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;br /&gt;
쓰레드는 실행 0.8초후 job의 cancelJob() method를 호출한다.&lt;br /&gt;
프로세스별 0.3 초간의 sleep이 있으므로 cancelJob()이 호출되는 시점은 대략적으로 ProcessC가 실행되는 시점이다.&lt;br /&gt;
&lt;br /&gt;위 코드를 실행하면 기대했던 A-&amp;gt;B-&amp;gt;C-&amp;gt;userCancel-&amp;gt;C&#039;-&amp;gt;B&#039;-&amp;gt;A&#039;의 실행흐름을 확인 할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;table style=&quot;display: inline; border-collapse: collapse&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://cfile21.uf.tistory.com/original/2079550D4AB42CF9733DE8&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile21.uf.tistory.com/image/2079550D4AB42CF9733DE8&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;result1.jpg&quot; height=&quot;170&quot; width=&quot;294&quot;/&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br /&gt;
&lt;br /&gt;C가 실행중 cancel 요청이 왔으므로 C의 process() method가 최종 return을 한후 재귀적인 rollback이 수행된다.&lt;br /&gt;
&lt;br /&gt;정리 :&lt;br /&gt;
필자가 프로그램 구현중 그냥 생각해본 디자인 방식(? 패턴?) 이다.&amp;nbsp;&lt;br /&gt;
Template method, Chain of resposibility의 아이디어로 적절히 조합한 형태이다.&lt;br /&gt;
앞서 언급한 바와 같이 UI 와 연결된 프로그램이라면 Observer pattern등을 적용하여 Job의 정교한 진행상태를 확인 할 수 있을 것으로도 생각되며, &lt;br /&gt;
Interrupt 기반의 cancel이 아니기에 수행시간이 긴 Process가 실행중 User Cancel이 왔을때 rollback 처리가 즉각적이지 못하다는 단점도 있으나, &lt;br /&gt;
여러 사람이 작업하는 프로젝트에서 손쉽게 프로세스를 구현하여 추가, 삭제가 가능하다는 장점이 있다.&lt;br /&gt;
&lt;br /&gt;더 좋은 아이디어가 있다면&amp;nbsp;알려주면 감사하겠다.. ^^&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;김영곤 (gonni21c@gmail)&lt;br /&gt;
&amp;nbsp;&lt;/P&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>Pattern Research</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/73</guid>

			<comments>http://jakarta.tistory.com/73#entry73comment</comments>

			<pubDate>Thu, 17 Sep 2009 00:05:27 +0900</pubDate>

		</item>

		<item>

			<title>[Parser개발] 자바의 고성능 문자열 처리 : Rope</title>

			<link>http://jakarta.tistory.com/72</link>

			<description>&lt;P&gt;Java에서는 문자열 처리를 위해서 String이라는 기본 Class를 제공합니다.&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;하지만 String은 구조적 특성상 속도상으로는 효율이 떨어지는 편입니다.&lt;/P&gt;&lt;P&gt;아래의 코드를 예로 들면,&lt;/P&gt;&lt;P&gt;String str = &quot;abc&quot; + &quot;def&quot; + &quot;gh&quot;;&lt;/P&gt;&lt;P&gt;str에는 &quot;abcdefgh&quot; 라는 문자열이 최종적으로는 저장되지만..&lt;/P&gt;&lt;P&gt;실제 str에 값이 할당되기 전까지 아래의 4개의 String 객체가 생성됩니다.&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;new String(&quot;abc&quot;);&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;new String(&quot;def&quot;);&lt;/P&gt;&lt;P&gt;new String(&quot;gh&quot;);&lt;/P&gt;&lt;P&gt;new String(&quot;abcdefgh&quot;);&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;new 로 4개의 객체가 생성되는데, 실제 프로그램에서 느껴지는 체감속도에는 크게 문제가 없는것 처럼 느껴지지만,&lt;/P&gt;&lt;P&gt;parser 개발시 추천, 수만의 위와 같은 String연산을 처리했을시 속도에는 치명적이다.&lt;/P&gt;&lt;P&gt;실제 객체지향 프로그램의 Coding에서 new 를 써서 객체를 &lt;/P&gt;&lt;P&gt;메모리상에 할당하는 시간의 비중이 프로그램 수행속도에  가장 큰 영향을 미친다고 볼수 있다.&lt;/P&gt;&lt;P&gt;즉, new를 사용하여 객체를 생성하는 것은 비용이 매우 높은 일중에 하나라 볼 수 있다&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;그래서 자바에서는 이러한 String상의 문제를 해결하기 위해 StringBuffer를 제공한다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;StringBuffer str = new StringBuffer(&quot;abc&quot;);&lt;/P&gt;&lt;P&gt;str.append(&quot;def&quot;);&lt;/P&gt;&lt;P&gt;str.append(&quot;gh&quot;);&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;실제 위의 코드는 String과는 달리 str 객체를 단한번 생성하고, 문자열을 추가시킨다.&lt;/P&gt;&lt;P&gt;원리는 String과 달리 StringBuffer는 문자열을 저장하기위해 초기배열을 10정도로 메모리상에 할당한다.&lt;/P&gt;&lt;P&gt;그래서 매번 메모리에 고정된 문자 저장 공간을 할당하는 String에 비해  객체생성에 대한 비용이 상당히 줄어들기 때문에,&lt;/P&gt;&lt;P&gt;문자열 처리의 연산속도가 String에 비해 상당히 빠르다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;하지만 StringBuffer도 고정크기 Buffer를 사용하므로, Buffer크기 이상의 문자열이 할당될 경우,&lt;/P&gt;&lt;P&gt;내부적으로 새로운 Buffer크기의 StringBuffer 객체를 생성하므로 자료의 구조에 따라 &lt;/P&gt;&lt;P&gt;일시적으로 속도가 느려지는 문제가 생긴다. 궁극의 해결책은 못된다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;String과 StringBuffer의 공통적인 문제는 문자열 저장을 위해 내부적으로는,&lt;/P&gt;&lt;P&gt;고정크기의 char 배열을 사용하는데 있어, 배열보다 큰 공간이 필요할때,&lt;/P&gt;&lt;P&gt;새로운 객체를 생성하기 때문에 시간적인 비효율이 존재한다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;그래서, 고정공간 배열이 아닌 Linked List 구조의 가변공간 기반의 자료형이 있으니,&lt;/P&gt;&lt;P&gt;이름하여 Java Rope이다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;아래의 사이트에 자세한 설명이 있으니 살펴보도록 하자.&lt;/P&gt;&lt;P&gt;http://www.ibm.com/developerworks/kr/library/j-ropes/index.html&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;아래는 특정 웹사이트의 URL의 내용을 긁어 오는 코드이다.&lt;br /&gt;


&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;&lt;TABLE width=&quot;673&quot; bgcolor=&quot;#e8e8e8&quot; style=&quot;border-collapse:collapse&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;&lt;TBODY&gt;&lt;TR&gt;&lt;TD style=&quot;border:1px solid #474747&quot; width=&quot;100%&quot;&gt; private void loadRope(URL url, int timeout) throws IOException&lt;br /&gt;
	{&lt;br /&gt;
  &lt;br /&gt;
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();&lt;br /&gt;
  &lt;br /&gt;
		String ct = conn.getContentType(), charset = &quot;euc-kr&quot;;&lt;br /&gt;
		if (ct.indexOf(&quot;charset=&quot;) &amp;gt; 0)&lt;br /&gt;
 		charset = ct.substring(&quot;charset=&quot;.length() + ct.indexOf(&quot;charset=&quot;));&lt;br /&gt;
&lt;br /&gt;
		conn.setConnectTimeout(timeout);&lt;br /&gt;
		conn.setInstanceFollowRedirects(true);&lt;br /&gt;
		String contentType = conn.getContentType();&lt;br /&gt;
&lt;br /&gt;
		if (contentType != null &amp;amp;&amp;amp; contentType.startsWith(&quot;text/html&quot;)) {&lt;br /&gt;
			InputStreamReader isr = new InputStreamReader(&lt;br /&gt;
					conn.getInputStream(), charset);&lt;br /&gt;
			BufferedReader br = new BufferedReader(isr);&lt;br /&gt;
			String line = null;&lt;br /&gt;
			//this.sBuf = new StringBuffer();&lt;br /&gt;
			while ((line = br.readLine()) != null) {&lt;br /&gt;
         &lt;STRONG&gt;this.rope.append(line + &quot;\r\n&quot;);&lt;/STRONG&gt;&lt;br /&gt;
			}&lt;br /&gt;
 	 br.close();&lt;br /&gt;
		} else {&lt;br /&gt;
			throw new IOException(&quot;Invalid URL :&quot; + url);&lt;br /&gt;
		}&lt;br /&gt;
	}&lt;br /&gt;
&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;br /&gt;
&lt;P&gt;&lt;/P&gt;&lt;P&gt;BufferedReader로 읽은 문자열을,&lt;/P&gt;&lt;P&gt;StringBuffer와 Rope를 이용해 수행 속도를 측정한 결과 Rope가 5배 이상 빠른 결과를 보여주었다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;물론,&lt;/P&gt;&lt;P&gt;Rope도 만능은 아니다. 하지만 Cursor의 rollback이 없는 parser(lexer)의 구현이라면, &lt;/P&gt;&lt;P&gt;사용해볼만한 가치가 충분히 있다고 보여진다.&lt;/P&gt;&lt;P&gt;&lt;br /&gt;
&lt;/P&gt;&lt;P&gt;김영곤(gonni21c@gmail)&lt;/P&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>YG Html Parser</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/72</guid>

			<comments>http://jakarta.tistory.com/72#entry72comment</comments>

			<pubDate>Sat, 12 Sep 2009 20:15:39 +0900</pubDate>

		</item>

		<item>

			<title>[구현패턴] 개요: 프로그래밍 원칙</title>

			<link>http://jakarta.tistory.com/69</link>

			<description>&lt;P&gt;&lt;table style=&quot;display: inline; border-collapse: collapse&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://cfile21.uf.tistory.com/original/15689E234A06B8FCEFE100&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile21.uf.tistory.com/image/15689E234A06B8FCEFE100&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;qna.jpg&quot; height=&quot;500&quot; width=&quot;333&quot;/&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br /&gt;
&lt;br /&gt;- 켄트 백 :&amp;nbsp;&amp;nbsp;프로그램을 짤 때는 자신과 컴퓨터뿐 아니라, 다른 사람들을 생각해야 한다!&amp;nbsp;&lt;br /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; ,공동체에 대한 기여가 개인으로써의 최대 목표&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
- 구현패턴 : 커뮤니케이션을 돕는 프로래밍기법에 초점&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
- 코드를 통한 커뮤니케이션을 위한 단계&lt;br /&gt;
&lt;br /&gt;1. 생각을 하며 프로그래밍 하는것&lt;br /&gt;
2. 다른 사람들의 중요성을 인정하는 것 - 프로그래밍은 한 사람과 기계 사이의 외로운 교류, 혹은 그이상&lt;br /&gt;
3. 구현패턴을 이용해 실천으로 옮기기&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
- 디자인패턴과 구현패턴&lt;br /&gt;
1. 디자인패턴 : 개발 기간 동안 하루에 몇 하례 해야하는 결정(보통 객체 간의 관계를 결정)&lt;br /&gt;
2. 구현패턴 : 몇 초에 한 번씩 하게 되는 결정&lt;br /&gt;
&lt;br /&gt;&lt;/P&gt;

&lt;P&gt;- 프로그램의 법칙&lt;br /&gt;
1.&amp;nbsp;새로 짜는 경우 보다 기존 프로그램을 읽는 경우가 많다.&lt;br /&gt;
2. 프로그램에 있어 &#039;완성&#039;은 없다. 최초 개발 비용보다 이후 수정 비용이 더 크다&lt;br /&gt;
3. 프로그램 구조는 몇 가지 상태와 제어 흐름 개념으로 결정된다&lt;br /&gt;
4. 프로그램을 읽는 사람은 개념과 더불어 세부 사항까지도 이해해야 한다.&lt;br /&gt;
&lt;br /&gt;- 패턴은 결정 요소들의 패턴이다.&lt;br /&gt;
- 결정 요소들 가의 상대적 우선 순위가 높은 패턴이 적용된다&lt;br /&gt;
&lt;br /&gt;- 패턴은 시간과 에너지를 줄여준다&lt;br /&gt;
- 패턴은 절대적인 진리가 아니므로, 사람의 의사 결정을 돕는 도구 정도로 생각하자.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;- 결정 사항에 영향을 미치는 동력 force : 가치value 와 원칙principle&lt;br /&gt;
&lt;br /&gt;- 가치 : 모든 프로그래밍에 적용되는 주제 : 커뮤니케이션, 단순성, 유연성&lt;br /&gt;
- 원칙 : 패턴 : 중요하지만 때로는 직접 적용하기 어려운 가치와, 적용법은 명확하지만 조금은 지엽적인 패턴 사이의 가교 역할&lt;br /&gt;
&lt;br /&gt;- 패턴 : 지금 당장 무엇을 해야 할지 알려주고,&lt;br /&gt;
- 가치: 패턴을 사용해야 하는 동기를 알려주며,&lt;br /&gt;
- 원칙 : 동기를 행동으로 어떻게 바꿔줄지 알려준다.&lt;br /&gt;
&lt;br /&gt;- 훌륭한 프로그램의 공통적 가치 : 커뮤니케이션, 단순성, 유연성, 확장성을 고래해서 프로그램을 짜지만, 불필요한 요소를 사용하지 않으며, 읽고 이해하기 쉬운 프로그램을 짜야한다.&lt;br /&gt;
&lt;br /&gt;[가치]&lt;br /&gt;
- 커뮤니케이션&lt;br /&gt;
&amp;nbsp;개발자가 코드를 쉽게 이해하고, 수정하고, 사용할 수 있는 상태&lt;br /&gt;
- 단순성&lt;br /&gt;
&amp;nbsp;의미 없는 코드는 모두 제거, 설계 시에도 과도한 요소는 모두 제거, 요구 사항을 분석해 꼭 필요한 사항만 뽑아내라&lt;br /&gt;
- 유연성&lt;br /&gt;
&amp;nbsp;개발 비용은 대부분 처음 프로그램이 작성된 후부터 들어간다, 프로그램의 수정은 가급적 쉬워야 한다.&lt;br /&gt;
&amp;nbsp;유연성이 있으면서도 당장 이득을 얻을 수 있는 패턴 사용&lt;br /&gt;
&lt;br /&gt;=&amp;gt; 구현패턴의 학습은 단순하고 이해하기 쉬우면서 수정이 쉬운 코드를 작성하는 것이 최종목표!!&lt;br /&gt;
&lt;br /&gt;[원칙]&lt;br /&gt;
- 지역적 변화&lt;br /&gt;
- 최소 중복&lt;br /&gt;
- 로직과 데이터의 결합&lt;br /&gt;
- 대칭성&lt;br /&gt;
- 선언적 표현&lt;br /&gt;
- 변화율&lt;/P&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>Pattern Research</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/69</guid>

			<comments>http://jakarta.tistory.com/69#entry69comment</comments>

			<pubDate>Sun, 10 May 2009 20:49:15 +0900</pubDate>

		</item>

		<item>

			<title>Java로 구현하는 웹기반 원격제어 프로그램</title>

			<link>http://jakarta.tistory.com/68</link>

			<description>&lt;br /&gt;
Simple remote control application based on Java.&lt;br /&gt;
&lt;br /&gt;반나절 걸려 대충 완성한 웹기반의 원격접속 제어 프로그램입니다.&lt;br /&gt;
Windows 에서만 test 해봤는데 파일 경로 문제로 Linux에서는 약간의 수정이 필요할 듯 하네요..&lt;br /&gt;
&lt;br /&gt;자바에서는 응용프로그램의 UI Test 용으로 Robot 라는 class를 제공합니다.&lt;br /&gt;
Robot를 이용하여 화면영역, Keyboard, mouse 등을 api를 통해 제어할 수 있습니다..&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://jakarta.tistory.com/attachment/cfile5.uf@1805A81B49EAF98A1F2719.jar&quot;&gt;&lt;img src=&quot;http://cfs.tistory.com/blog/image/extension/unknown.gif&quot; alt=&quot;&quot; style=&quot;vertical-align: middle;&quot; /&gt; ygRemoteControl.jar&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
위의 프로그램을 다운 받아서 아래와 같이 실행하면 현재 화면&amp;nbsp;웹서버가 가동됩니다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile5.uf.tistory.com/original/162C0F1E49EAFC26572A72&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile5.uf.tistory.com/image/162C0F1E49EAFC26572A72&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;console.jpg&quot; height=&quot;132&quot; width=&quot;659&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
default로 8181 포트에서 동작하지만 사용자가 임의로 포트를 설정할 수 도 있습니다.&lt;br /&gt;
위의 명령어는 8989 port에서 웹서버를 가동 시킵니다.&lt;br /&gt;
&lt;br /&gt;브라우저를 열고 주소창에 다음과 같이 입력합니다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile2.uf.tistory.com/original/133A1B1649EB04212A6F1F&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile2.uf.tistory.com/image/133A1B1649EB04212A6F1F&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;addr.jpg&quot; height=&quot;92&quot; width=&quot;480&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&lt;br /&gt;그러면 아래와 같은 현재 캡쳐된 바탕화면이 뜹니다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile22.uf.tistory.com/original/113B611649EB056950FE10&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile22.uf.tistory.com/image/113B611649EB056950FE10&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;backCap.jpg&quot; height=&quot;599&quot; width=&quot;650&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
이미지의 특정 부분을 클릭하면, 로컬 pc에서 마우스 포인터가 화면상 지정위치와 같은 위치에서 클릭이 일어납니다.&lt;br /&gt;
(내부적으로 이미지 클릭좌표는 자바스크립트로 추출,&amp;nbsp;HTTP GET protocol spec으로 서버와 동작합니다.)&lt;br /&gt;
물론 대충 만들어서 화면의 갱신속도는 일반 사용프로그램과 비교시 매우 느린 편입니다.&lt;br /&gt;
또한 현재 지원 되는 이벤트는 마우스 클릭뿐입니다.&lt;br /&gt;
&lt;br /&gt;하지만 별도 프로그램 필요없이 별도의 브라우저만 열어서 집이나 회사의 PC를 원격제어 할 수 있다는 점에서&amp;nbsp;괜찮은 시도가 아닌가 생각됩니다..(^^흐뭇..)&lt;br /&gt;
브라우저가 내장된 PDA에서도 접속해서 쉽게 사용할 수 있으니까요..&lt;br /&gt;
&lt;br /&gt;향후 키입력이나, 드래그앤 드뢉, 분할 이미지 전송, Session 기반 사용자 AA, 시스템 트레이 등을 구현할 예정입니다.&lt;br /&gt;
&lt;br /&gt;현재의 구현상태로 주식HTS 프로그램 뛰워두고 입력이 많이 필요치 않은 정적인 작업으로 쓰기에 큰 부족함은 없을 듯 하네요.. 직장내에서 몰래 주식질 하는 묘미란..ㅎㅎ&lt;br /&gt;
&lt;br /&gt;** 참고로 웹서버 부분의 구현은 최범균님의 NIO기반 Simple http server 코드를 약간 수정하였습니다.&lt;br /&gt;
** 코드는 정리후 공개하도록 하겠습니다.&lt;br /&gt;
** 급하신 분들은 첨부 파일을 역컴파일 하셔도 되겠습니다..ㅋ&lt;br /&gt;
&lt;br /&gt;

&lt;DIV style=&quot;TEXT-ALIGN: right&quot;&gt;김영곤(&lt;A href=&quot;mailto:gonni21c@gmail.com&quot;&gt;gonni21c@gmail.com&lt;/A&gt;)&lt;br /&gt;
&lt;br /&gt;&lt;/DIV&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>Java Works</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/68</guid>

			<comments>http://jakarta.tistory.com/68#entry68comment</comments>

			<pubDate>Sun, 19 Apr 2009 20:21:39 +0900</pubDate>

		</item>

		<item>

			<title>리움을 다녀오다..</title>

			<link>http://jakarta.tistory.com/66</link>

			<description>&lt;br /&gt;
리움은 삼성문화제단에서 운영하는 사설 갤러리.. &lt;br /&gt;
대기업의 막대한 자본력으로 국립미술관, 혹 박물관 이상의 수준높은 소장품을 보유 전시하고 있다. &lt;br /&gt;
도슨트의 예기로는 대부분의 유명 전시물은 작품보호를 위해 복제품으로 전시를 하는 경우도 많다하지만,&lt;br /&gt;
리움의 모든 전시물은 진품이라 그런다.&lt;br /&gt;
&lt;br /&gt;국보, 보물급 유물에서 부터 현대미술에 이르기까지,&lt;br /&gt;
미술관이라기 보다는 작은 박물관과 미술관을 한곳에 모아 놓은 느낌도 받게된다..&lt;br /&gt;
보물창고 같은 느낌도 들지만 스케일이 너무 큰 느낌도 들고..&lt;br /&gt;
&lt;br /&gt;사실, 미술관의 전시된 전시물의 퀄리티도 중요하지만 전시물과 미술관이 얼마나 잘 공존, 어울리는가 또한,&lt;br /&gt;
본인의 생각인바..&lt;br /&gt;
미술관을 찾게되면 전시물 구경도 중요하지만 항상, 미술관 건물과 주변의 환경등을 먼저 살피게 된다..&lt;br /&gt;
&lt;br /&gt;쉽게말해, 미술관 자체 만으로도 예술이 되어야 한다는게 내 생각..&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile25.uf.tistory.com/original/1144FB1D49D8AC457643F9&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile25.uf.tistory.com/image/1144FB1D49D8AC457643F9&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01901.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
일단 리움에 가서 제일 먼저 보게되는, 어떻게 보면 리움의 상징과도 같은 거미..&lt;br /&gt;
왠만한 건물 3층에 육박하는 거대한 작품으로,&amp;nbsp; 담장넘어 보이는 모습이 웅장하다..&lt;br /&gt;
담장 바로 건너편은 주택가이니, 이런 거대한 작품을 보유하고 있는 미술관을 바로옆에 산다고 생각하니..&lt;br /&gt;
부럽기도 하고.. =ㅅ=&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile3.uf.tistory.com/original/1444FB1D49D8AC43723C46&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile3.uf.tistory.com/image/1444FB1D49D8AC43723C46&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01886.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
루이스 부르주아(Louise Bourgeois )의 작품으로 세계 곳곳에 7개 정도의 똑 같은 작품이 있다 그런다.&lt;br /&gt;
&lt;A href=&quot;http://blog.naver.com/driptrip?Redirect=Log&amp;amp;logNo=50008524518&quot;&gt;http://blog.naver.com/driptrip?Redirect=Log&amp;amp;logNo=50008524518&lt;/A&gt;&lt;br /&gt;
다른 나라의 거미들은 사람들이 붐비는 거리에 위치하고 있지만,&lt;br /&gt;
리움의 거미는 외딴 주택가를 지키고 있으니, 왠지 모를 번지수를 잘 못 찾았다는 씁쓸한 기분이 들기도 하고..&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile2.uf.tistory.com/original/1744FB1D49D8AC4473FDBD&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile2.uf.tistory.com/image/1744FB1D49D8AC4473FDBD&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01889.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
사진찍기 좋게 친절하게, 여느 미술관에서나 볼 수 있는 이런 벤치도 있다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile25.uf.tistory.com/original/2044FB1D49D8AC457522BD&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile25.uf.tistory.com/image/2044FB1D49D8AC457522BD&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01898.jpg&quot; height=&quot;800&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
리움으로 들어가는 입구, 바닥에 LED 가 알 수 없는 숫자로 번쩍거린다.&lt;br /&gt;
어느 미술관에서도 느껴보지 못한 깔끔함, 입구 주변은 보안요원 들이 곳곳에 배치되어 있다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile24.uf.tistory.com/original/1244FB1D49D8AC4577C92B&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile24.uf.tistory.com/image/1244FB1D49D8AC4577C92B&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01905.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
리움의 외부건물 모습, 여느 미술관과 마찬가지로 외국의 유명 건축가가 디자인 하였다고 한다. &lt;br /&gt;
사진상의 건물은 국내외 현대 미술 작품이 전시된 2관(?)..&lt;br /&gt;
박스형태의 공간이 조합되어 하나의 건물을 구성하고 있으며, 실제 내부에 들어가서 관람을 하면, 여러개의 방을 돌아다니며 전시물들을 관람하는 듯한 느낌도 받는다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile3.uf.tistory.com/original/1744FB1D49D8AC477BA3F0&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile3.uf.tistory.com/image/1744FB1D49D8AC477BA3F0&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01913.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&amp;nbsp;좌측에 보이는 건물에는 국보, 보물급 국내유물 들이 전시되어 있다. &lt;br /&gt;
유물도 미술의 범주에서 보는게 맞는듯 하나, 여긴 그냥 박물관이라고 보는게 맞는것 같다. &lt;br /&gt;
가야 왕관을 비롯하여, 고려, 조선 시대의 도자기, 불교유물 등등 국립중앙박물관에 비해 스케일은 작지만, 모든 유물 하나하나가 알차다.&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;

&lt;DIV&gt;&amp;nbsp;사진속 거미는 이전의 거대 거미 옆, 작은 거미..&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile24.uf.tistory.com/original/1544FB1D49D8AC46796B5B&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile24.uf.tistory.com/image/1544FB1D49D8AC46796B5B&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01908.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
건물의 외벽은 이 미술관 착공당시에 출토되었던 암석들을, 잘게 부수어 외벽을 구성하였다고 한다.&lt;br /&gt;
미술관 내의 창으로는 외벽의 모습을 자세히 볼 수 있는데,&lt;br /&gt;
외벽의 모습과 작품이 적절히 잘 조화를 이루도록 하기위한 인위적인 디자인이라 그런다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile24.uf.tistory.com/original/1544FB1D49D8AC477A97E8&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile24.uf.tistory.com/image/1544FB1D49D8AC477A97E8&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01912.jpg&quot; height=&quot;450&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
사실 여러 미술관들을 돌아다녀 봤으나,&lt;br /&gt;
리움처럼 관리나 시설측면에 깔끔한 미술관은 본적이 없는 것 같다. 해외의 미술관까지 포함해서&amp;nbsp;말이다..&lt;br /&gt;
미술관 곳곳에 검은색 정장차림의 보안요원들이 배치되어 작품관리에 철저한 신경을 쓰는거 같다..&lt;br /&gt;
&lt;br /&gt;여느 미술관에서나 볼 수 있는 애들이 뛰어다니고, 난잡 스러운 모습을..&lt;br /&gt;
리움에서는 볼 수가 없었다..&lt;br /&gt;
관리의 리움인가..&lt;br /&gt;
전시장 모든 곳이 차분하고 조용하다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile21.uf.tistory.com/original/1844FB1D49D8AC44749DC6&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile21.uf.tistory.com/image/1844FB1D49D8AC44749DC6&quot; alt=&quot;&quot; filemime=&quot;image/jpeg&quot; filename=&quot;DSC01897.jpg&quot; height=&quot;800&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/DIV&gt;&lt;br /&gt;
&amp;nbsp;미술관은 공개된 공간이다..&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;미술관 자체와, 미술관에 전시된 전시물과 관람객이 하나가 되어, 그것 자체가 하나의 공간에서 일어나는 하나의 퍼포먼스, 행위 예술의 순간이라 생각한다.&amp;nbsp;북적거림 속의 난잡함도 어디까지나 시간속에서 현재의 미술관을 만들어내는 하나의 에너지라 생각한다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;하지만, 리움에는 그런 에너지가 없다. 억압된 느낌을 많이 받는다.&lt;br /&gt;
압도적인 퀄리티의 작품, 숨이 막히게 뛰어난 작품들.. &lt;br /&gt;
어딜 봐도 빈틈이 없었다..&lt;br /&gt;
곳곳에 배치된 검은 정장의 보안요원들에 의해, 미술관을 들어서는 순간부터 나가는 그 순간까지 감시당하는 느낌..&lt;br /&gt;
뭔가로 부터 압도되어 항상 눌려있는 듯한 느낌..&lt;br /&gt;
외부 세계보다 중력이 2배는 강하고, 산소의 밀도가 지나치게 높아서 숨을 쉬기 부담스러운 그런 느낌..&lt;br /&gt;
&lt;br /&gt;미술관을 나서며, 그 모든 느낌에서 해방되는 기분은.. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
결론 : 그냥 그렇다고.. =ㅅ=&lt;br /&gt;&lt;div class=&quot;blogger-news-widget&quot; style=&quot;width: 100%; text-align: center&quot;&gt;	        

		  					&lt;embed src=&quot;http://api.v.daum.net/static/recombox1.swf&quot; quality=&quot;high&quot; flashvars=&quot;nid=2874302&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;false&quot; bgcolor=&quot;#ffffff&quot; width=&quot;400&quot; height=&quot;80&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;

						&lt;/div&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>횡설수설</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/66</guid>

			<comments>http://jakarta.tistory.com/66#entry66comment</comments>

			<pubDate>Sun, 05 Apr 2009 22:50:12 +0900</pubDate>

		</item>

		<item>

			<title>혼다 시빅2.0 (Honda Civic 2.0) 주행성 위주 시승기..</title>

			<link>http://jakarta.tistory.com/61</link>

			<description>&lt;br /&gt;
이제 시빅을 구입한지 2달이 되었고, 계기판에 주행거리는 3,500km 정도가 찍혀있다.&lt;br /&gt;
집이 부산인지라 집에 한번 갔다오면 주행거리가 1000km 정도는 올라가는 상황이었던지라..&lt;br /&gt;
차량구입후 거의 대부분의 주행을 고속주행만 하였다.&lt;br /&gt;
&lt;br /&gt;이 참에 이 차의 주행성 위주의 시승기를 정리해 보고자 한다. &lt;br /&gt;
** 일단 필자는 자동차 매니아도 아니고 그냥 스트레스 해소용으로 자동차를 모는 컴퓨터 프로그래머이니 내용상 이상이 있더라도 쌍욕은 자제바람..&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;아래의 사진은 혼다 시빅 일본형 2009 버전이다. 국산은 일본형에 거의 풀옵션을 장착하여 들여옴으로, 외양은 완전히 같다.(단지&amp;nbsp;잘나온 사진을 찾다보니..) &amp;nbsp;넓은 앞유리와 그것을 활용한 넓은 앞좌석 공간이 특징..&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile22.uf.tistory.com/original/150DA51649AA31CBA752AB&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile22.uf.tistory.com/image/150DA51649AA31CBA752AB&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;2009_Honda_Civic1.jpg&quot; height=&quot;441&quot; width=&quot;620&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&amp;nbsp;엔진은 기술의 혼다, 엔진의 혼다를 상징하는 i-vtec 2000cc 엔진이 탑재되어 있고, 4500rpm에 19.7 수준의 토크와 6000rmp에서 최대 155마력의 힘을 발생시킨다. 국내에 판매되는 시빅은 자동 5단&amp;nbsp;기어가 장착된다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;혼다차를 상징하는 메커니즘의 엔진인 만큼 뭔가 다른게 있을까 하고 주행을 해보니, 그동안 몰았던 중형세단, SM5나 세타엔진의 소나타와는 상당히 다른 주행성을 보여준다. 일단 엔진에서 RPM이 튀어오르는(증가) 속도가 타엔진에 피해 상당히 빠르다. 즉 엔진의 반응성이 상당히 좋은것 같다. 2000rpm으로 달리다가도 풀악셀시 기어는 킥다운되고 레드존 가까이 바늘이 움직이기까지 시간이 거의 느껴지지 않는다. (눈 깜짝할&amp;nbsp;새의 엔진 반응성)&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;혹자들은 iVtec엔진은 엔진이 가진 최대의 능력치를 쥐어짜서 최대의 힘, 마력을 내는 엔진이라 말을 한다. 기술적으로는 흡배기 타이밍을 조절하여 특정 rpm 구간, 4000rpm이상에서는 가속을 위한 힘 위주의 엔진 세팅으로 작동하고, 그 이하 실용영역에서는 연비위주로 작동하는 듯 하다.즉, 4000rpm을 기준으로 자동차의 반응성 및&amp;nbsp;주행용도가 확연히 차이가 나는 엔진 세팅으로 봐도 무방할 듯 하다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;그래서 그런지 이차는 저 RPM 위주의 운행시 특별히 치고 나간다는 느낌을 받지 못한다. 특히 1단 기어 상태에서 차는 상당히 무거운 느낌이다. D모드에서 출발은 국산 1.6수준의 준중형과 별반 차이가 없이 느껴질 수도 있다. 하지만 D모드 기준 50km/h 정도의 속도에 도달하면, 엑셀을 밟았을때 치고나가는 느낌은 국산준중형이나 중형에서 느껴보지 못했던,&lt;br /&gt;
가속시 뭔가가 지속적으로 밀어주는 느낌을 받는다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;속도가 올라갈 수록 이런 느낌은 지속되며 더욱 강해지는 느낌을 받는다. 시속 210키로 까지는 무리없이 이 힘을 받으며 가속되는 듯한 느낌이었다. 혼다에서 이차의 최고속과 제로백에 대한 제원은 밝히지는 않고 있으나 최고속은 235키로 정도 나오는 듯 하며, 제로백은 스포츠 모드에서 8초 중반대는 나오는듯 하다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile21.uf.tistory.com/original/110DA51649AA31CBA84923&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile21.uf.tistory.com/image/110DA51649AA31CBA84923&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;2009_Honda_Civic2.jpg&quot; height=&quot;441&quot; width=&quot;620&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&amp;nbsp;사실 이정도 성능이면 일반적은 패밀리 세단 수준을 넘어서는 수준의 주행력, 그렇다고 란에보같은 2000cc 급의 스포츠세단이라 보기도 애매하고, 그래서 혼다는 이 차를 &#039;콤펙트 다이나믹 세단&#039;이라는 말로 정의하고 있는데, 적절한 것 같다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;이 차를 몰면 몰수록 느끼는 거지만, 이 차는 초기 설계때 부터&amp;nbsp;&#039;컴팩트 다이나믹 세단&#039; 이라는&amp;nbsp;목적을 가지고, 그 목적에 맞추어 모든 설계와 부품이 하나 세팅되었다는 느낌이 든다. 즉, 파워트레인부터 내장, 외장에 이르는 모든 부품들이 최적의 조합으로 맞물려 있는 듯한 느낌을 받았다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;결론적으로, 이 차의 최초의 제작 목적은 국산차에서 보여지는 패밀리 세단 위주의 세팅은 아니며, 주행성에 많은 역점을 둔듯하다. 이차의 서스펜션은 고속주행을 위해 상당히 딱딱하게 세팅되어 있어 노면의 상황을 그대로 느낄 수 있으며, 핸들링도 일반적으로 국산에서 비해 반응성이 좋으며, 코너링도 날카롭다. 전자제어형 속도감응 핸들로 속도가 증가할 수록 핸들이 무거워지지만 전반적으로 핸들은 무거운 편, 고속위주의 주행과 터프한 주행을 위한 핸들 세팅으로 보인다. 2.0에는 차체자세제어장치(VSA)의 장착되어 있으나 아직까지 급격한 코너링이나 핸들링의 주행은 해보질 않아 VSA의 작동을 확인할 기회는 없었다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;또한, 앞서 언급한 바와 같이 초기 제작 의도는&amp;nbsp;오직 주행성이지, 애초에 고급차로 만들기 위한 의도는 전혀 없었던 것 같다. 즉 시빅은 탄생부터 고급차가 아니고 중산층(서민)을 위한 차다. 필자가 중산층을 위한 차라는 이야기를 꺼내는 의도는 이 차의 옵션 때문이다. 주행성을 위해, 고급차에나 장착될 법한 크루즈 컨트롤과 같은 편의 장치가 있지만, 3천만원이라는 가격대에서 왠만한 국산차에는 다 장착될 법한&amp;nbsp;우적감시센서, ECM &amp;nbsp;룸밀러, 오토헤드라이트, 유압식 본네트 지지대, USB 입력단자, 네비게이션 매립 공간등이 빠져있다. 거기다 이 차의 하체소음은 국산 중형 이상차를 몰던 사람들에게는 테러에 가까운 수준이라고 표현해도 될 만큼 심각하다. 하체소음으로 인해 140키로 정도의 속도에서 옆사람과 작은 목소리로 대화가 힘들다.&lt;br /&gt;
(주행성은 시빅에 비해 떨어지지만&amp;nbsp; 미쯔비시의 랜서2.0은 씨빅의 이런한 약점을 파고 들고 나온듯 하다)&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;이렇게 열악한 가운데 이 차가 팔리는 이유는 대부분의 사람들이 주행성에 반해서 일것이다. &lt;br /&gt;
실제 우리나라만 소음에 유독 민감하며, 해외에서는 시빅 소음으로 별말 없다 그러니, 소음은 개인적인 선택의 문제일런지도 모르겠다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfile4.uf.tistory.com/original/1265A91749AA3D1C089140&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfile4.uf.tistory.com/image/1265A91749AA3D1C089140&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;DSC01742.jpg&quot; height=&quot;480&quot; width=&quot;640&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&amp;nbsp;어쨌거나 시빅2.0은 자동기어이긴 하지만 D모드와 S모드로 구분, S모드에서 핸들에 달린 패들시프트로&amp;nbsp; 기어의 수동 조작이 가능하다.&amp;nbsp;반응성은 골프GTI의 DSG에 비해 떨어진다는 평가지만,&amp;nbsp;이차가 가진 한계 능력선에서&amp;nbsp;극한의 주행을 하기에는 부족함이 없어보인다. &amp;nbsp;(골프에 비해 떨어지는 힘? 낮은 가격?, 이정도는 용서가 된다는 합리화.. -_-)&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;이 차는 D모드로 고속주행시, 엑셀을 살짝만 밟아도 기어의 킥다운이 일어나면서 vtec 가동 구간으로 rpm이 증가한다. 가속감은 좋으나 고 rpm의 잦은 사용은 연비에는 좋지 않을 것이다. S모드로 수동조작시 자신이 원하는 시점에 기어조작이 가능하므로, 적절한 시점에 패들시프트만 잘 사용하여도 고속에서의 연비절감 효과는 있어보인다. 물론 와일드한 스포티한 주행을 위해 패들 시프트를 쓰는 것도 두말할 나위 없으며, 급감속시 엔진브레이크로도 사용할 수 있다. 실제 고속도로에서 주행시 브레이크의 사용없이 패들시프트를 통한 엔진브레이크 조작만으로도 카메라앞에서 속도를 줄인다거나 차간거리 조절시 유용하게 사용할 수 있었다.&lt;br /&gt;
&lt;br /&gt;스포츠 모드를 사용하여 어느 정도는 연비를 절감할 수 있다지만 이차의 연비는 그렇게 좋은 편은 아니다. 시내주행시 국산 중형과 거의 비슷한 7+km/h 수준이며, 고속에서는 100km 정속 운행시 12.5키로 정도, 120~170km/h 정도 운행시 11.5키로로 큰 차이가 없어, 고속에선 어느정도 밟고 다녀도 연비에는 큰 영향을 주지 않아 밟고 다녀도 부담없는 차가 아닐 까 생각된다. 사실 연비 생각하고 타고 다닐 차는 절대 아니다. &lt;br /&gt;
&lt;br /&gt;참고로 부산-&amp;gt;수원(신대구부산&amp;nbsp;-&amp;gt; 경부고속 -&amp;gt; 중부내륙 -&amp;gt; 영동고속도로)&amp;nbsp;380km 구간을 3시간 30분 정도에 왔을때, 기름값은 5만원정도(리터당 1500원대) 가 나왔다. 이 구간을 3시간 30분만에 올려면&amp;nbsp;적절한 칼치기(-_-)와 120 ~ 170 정도의 속도를 유지해야 한다. &lt;br /&gt;
&lt;br /&gt;고속에서는 수동모드 기준 100km/h 주행시 rpm은 2200 정도이며 5단기어에서 170km/h 정도에 도달하면 rpm이 4천정도로 충분한 여유가 있음에도 풀악셀에도 더이상 반응하지 않았다. 그 상태에서 기어를 4단으로 바꾸며 다시 미친듯이 가속을 시작한다. 국산 중형은 속도가 170 정도에 도달하면 차가 도로위를 떠서 달리는 기분, 사이드 미러가 날아갈 법한 풍절음에 상당한 불안감이 느껴졌지만, 시빅2.0은 200km 대의 속도에서도 상당히 안정적인 느낌이었다. 낮은 차체로 인해 차가 도로위에 바짝 눌려서 달리는 기분이랄까, 또한 이 속도로 밟아보면 차량의 주행에 있어 단단한 하체의 중요성을 절감하게 된다. 강한 하체가 없다면 아무리 강력한 엔진을 달아도 주행 안정성을 보장할 수 없을 것이고 드라이버는 마음놓고 주행을 할 수가 없을 것이다. 솔찍히 이전 차를 몰때까지만 해도 하체의 중요성을 몰랐으나, 시빅은 그게 얼마나 중요한 것인지를 알게 해줄 만큼 고속주행에서의 어느 정도 주행 완성도를 보여주었다.&lt;br /&gt;
&lt;br /&gt;정리하면,&lt;br /&gt;
&amp;nbsp;국내에서 시빅2.0을 3천만원이라는 가격에 산다그러면, 대부분 이차를 타보질 않은 사람들은 비싸네, 미국에선 서민, 대학생이나 타는 차를 국산 준중형이나 사고 말지, 그랜져나 소나타2.4를 사내 식의 말이 많다. 그럼에도 이차가 팔리는 이유는 무엇일까?&amp;nbsp;&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;이 차를 사는 사람들 상당수가 이전에&amp;nbsp;국산중형 내지는 준중형을 몰아본 경험이 있던 사람들로 생각된다. 그랜저 정도의 예산은 있으나&amp;nbsp;큰차는 원하지 않고, 준중형급에서 고성능 세단을 원하는 사람들이 이 차를 사는 사람들일 것이다. 사실 국산 준중형 중에 이정도 급의 주행성을 가진 차가 있었다면, 필자는 당연히 국산을 샀을 것이다. 시장에는 골프와 같은 고성능 준중형에 대한&amp;nbsp;수요와 시장이 존재하지만 아직 까지는 국내 자동차 업체는&amp;nbsp;수익성이 작다는 이유로&amp;nbsp;이 시장을 포기하고 있고 외산업체가 잠식하고 있는 그 시장에서 가장 저렴한 차가 시빅이다. &amp;nbsp;그래서 시빅이 저렴하지 않은 가격에도 잘 팔리고 있는것 같다.&lt;br /&gt;
&lt;br /&gt;&amp;nbsp;글을 쓰고 보니 혼다 영업사원 스러운 글이 되버렸지만, &lt;br /&gt;
&lt;br /&gt;&amp;nbsp;국산을 타고 싶었지만, 원하는 성능의 차가 없어 결국&amp;nbsp;합리성을 따지는 개인의 시장논리에 의해 일본차를 사버린 한 사람으로써, 국산 준중형, 중형 차의&amp;nbsp;파워트레인을 비롯한 완성도의 향상을 기대해 본다.&lt;br /&gt;
&amp;nbsp;&lt;br /&gt;&lt;div class=&quot;blogger-news-widget&quot; style=&quot;width: 100%; text-align: center&quot;&gt;	        

		  					&lt;embed src=&quot;http://api.v.daum.net/static/recombox1.swf&quot; quality=&quot;high&quot; flashvars=&quot;nid=2636434&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;false&quot; bgcolor=&quot;#ffffff&quot; width=&quot;400&quot; height=&quot;80&quot; type=&quot;application/x-shockwave-flash&quot; wmode=&quot;transparent&quot;&gt;&lt;/embed&gt;

						&lt;/div&gt;&lt;fieldset style=&quot;margin:20px 0px 20px 0px;padding:5px;&quot;&gt;&lt;legend&gt;&lt;span&gt;&lt;strong&gt;크리에이티브 커먼즈 라이선스&lt;/strong&gt;&lt;/span&gt;&lt;/legend&gt;&lt;!--Creative Commons License--&gt;&lt;div style=&quot;float: left; width: 88px; margin-top: 3px;&quot;&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;&lt;img alt=&quot;Creative Commons License&quot; style=&quot;border-width: 0&quot; src=&quot;http://i.creativecommons.org/l/by-nc-nd/2.0/kr/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 92px; margin-top: 3px; text-align: justify;&quot;&gt;이 저작물은 &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; target=_blank&gt;크리에이티브 커먼즈 코리아 저작자표시-비영리-변경금지 2.0 대한민국 라이선스&lt;/a&gt;에 따라 이용하실 수 있습니다.

			&lt;!-- Creative Commons License--&gt;

			&lt;!-- &lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;

			&lt;Work rdf:about=&quot;&quot;&gt;

			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-nc-nd/2.0/kr/&quot; /&gt;

			&lt;/Work&gt;

			&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-nc-nd/&quot;&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;

			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;

			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;&lt;prohibits rdf:resource=&quot;http://web.resource.org/cc/CommercialUse&quot;/&gt;&lt;/License&gt;&lt;/rdf:RDF&gt; --&gt;&lt;/div&gt;&lt;/fieldset&gt;</description>

			<category>횡설수설</category>

			<author>과묵</author>

			<guid>http://jakarta.tistory.com/61</guid>

			<comments>http://jakarta.tistory.com/61#entry61comment</comments>

			<pubDate>Sun, 01 Mar 2009 17:43:57 +0900</pubDate>

		</item>

	</channel>

</rss>
